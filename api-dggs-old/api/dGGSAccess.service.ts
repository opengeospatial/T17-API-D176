/**
 * DGGS 1.0 server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.19-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { Collection } from '../model/models';
import { Exception } from '../model/models';
import { ZoneCollectionGeoJSON } from '../model/models';
import { ZoneGeoJSON } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class DGGSAccessService {

    protected basePath = 'https://tb16.geo-solutions.it/geoserver/ogc/dggs';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Get the list of child zones, to a given zone. Question, should it return just a list of identifiers instead of a GeoJSON collection?
     * @param collectionId local identifier of a collection
     * @param zoneId 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param levels Number of levels for zone parent/children extraction
     * @param properties A comma-separated list of values with names of observable properties that should be returned in the response. The default is to return all observed properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdChildrenGet(collectionId: 'H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, levels?: number, properties?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<ZoneCollectionGeoJSON>;
    public collectionsCollectionIdChildrenGet(collectionId: 'H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, levels?: number, properties?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdChildrenGet(collectionId: 'H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, levels?: number, properties?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdChildrenGet(collectionId: 'H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, levels?: number, properties?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdChildrenGet.');
        }
        if (zoneId === null || zoneId === undefined) {
            throw new Error('Required parameter zoneId was null or undefined when calling collectionsCollectionIdChildrenGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (zoneId !== undefined && zoneId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>zoneId, 'zone_id');
        }
        if (datetime !== undefined && datetime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>datetime, 'datetime');
        }
        if (levels !== undefined && levels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>levels, 'resolution');
        }
        if (properties) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                properties.join(COLLECTION_FORMATS['csv']), 'properties');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/geo+json',
                'application/dggs+json',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<ZoneCollectionGeoJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/children`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Describes a particular DGGS
     * @param collectionId local identifier of a collection
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'text/html', context?: HttpContext}): Observable<Collection>;
    public collectionsCollectionIdGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'text/html', context?: HttpContext}): Observable<HttpResponse<Collection>>;
    public collectionsCollectionIdGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'text/html', context?: HttpContext}): Observable<HttpEvent<Collection>>;
    public collectionsCollectionIdGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'text/html', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdGet.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json',
                'text/html'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<Collection>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of neighboring zones, to a given zone. Questions for further discussion: - Should it return just a list of identifiers instead of a GeoJSON collection? - Could this even be a list of links in the zone itself?
     * @param collectionId local identifier of a collection
     * @param zoneId 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param radius Distance, in zones, from the center zone, to be walked when extracting neighbours. Also known as &#x60;&#x60;k&#x60;&#x60; in a k-ring extraction in some DGGSs.
     * @param properties A comma-separated list of values with names of observable properties that should be returned in the response. The default is to return all observed properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdNeighborsGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, radius?: number, properties?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<ZoneCollectionGeoJSON>;
    public collectionsCollectionIdNeighborsGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, radius?: number, properties?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdNeighborsGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, radius?: number, properties?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdNeighborsGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, radius?: number, properties?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdNeighborsGet.');
        }
        if (zoneId === null || zoneId === undefined) {
            throw new Error('Required parameter zoneId was null or undefined when calling collectionsCollectionIdNeighborsGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (zoneId !== undefined && zoneId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>zoneId, 'zoneId');
        }
        if (datetime !== undefined && datetime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>datetime, 'datetime');
        }
        if (radius !== undefined && radius !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>radius, 'radius');
        }
        if (properties) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                properties.join(COLLECTION_FORMATS['csv']), 'properties');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/geo+json',
                'application/dggs+json',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<ZoneCollectionGeoJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/neighbors`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of parent zones, to a given zone. Questions for further discussion: -  Should it return just a list of identifiers instead of a GeoJSON collection?
     * @param collectionId local identifier of a collection
     * @param zoneId 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param levels Number of levels for zone parent/children extraction
     * @param properties A comma-separated list of values with names of observable properties that should be returned in the response. The default is to return all observed properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdParentsGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, levels?: number, properties?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<ZoneCollectionGeoJSON>;
    public collectionsCollectionIdParentsGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, levels?: number, properties?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdParentsGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, levels?: number, properties?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdParentsGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, levels?: number, properties?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdParentsGet.');
        }
        if (zoneId === null || zoneId === undefined) {
            throw new Error('Required parameter zoneId was null or undefined when calling collectionsCollectionIdParentsGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (zoneId !== undefined && zoneId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>zoneId, 'zoneId');
        }
        if (datetime !== undefined && datetime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>datetime, 'datetime');
        }
        if (levels !== undefined && levels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>levels, 'levels');
        }
        if (properties) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                properties.join(COLLECTION_FORMATS['csv']), 'properties');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/geo+json',
                'application/dggs+json',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<ZoneCollectionGeoJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/parents`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the id of the zone containing the given point, at the given resolution
     * @param collectionId local identifier of a collection
     * @param resolution 
     * @param point Only zones that contain/touch the point are returned.  The point is provided in axis order:  * Longitude * Latitude  The CRS of the values is WGS 84 with axis order longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84).
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param properties A comma-separated list of values with names of observable properties that should be returned in the response. The default is to return all observed properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdPointGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, point?: Array<number>, datetime?: string, properties?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<ZoneCollectionGeoJSON>;
    public collectionsCollectionIdPointGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, point?: Array<number>, datetime?: string, properties?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdPointGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, point?: Array<number>, datetime?: string, properties?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdPointGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, point?: Array<number>, datetime?: string, properties?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdPointGet.');
        }
        if (resolution === null || resolution === undefined) {
            throw new Error('Required parameter resolution was null or undefined when calling collectionsCollectionIdPointGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (point) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                point.join(COLLECTION_FORMATS['csv']), 'point');
        }
        if (resolution !== undefined && resolution !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>resolution, 'resolution');
        }
        if (datetime !== undefined && datetime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>datetime, 'datetime');
        }
        if (properties) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                properties.join(COLLECTION_FORMATS['csv']), 'properties');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/geo+json',
                'application/dggs+json',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<ZoneCollectionGeoJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/point`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Lists zones contained in the polygon
     * @param collectionId local identifier of a collection
     * @param resolution 
     * @param bbox Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the  CRS includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  The CRS of the values is WGS 84 in longitude/latitude order (CRS84) unless a different coordinate reference system is specified in the parameter &#x60;bbox-crs&#x60;.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
     * @param polygon Only zones contained in the polygon are returned. The polygon is specifed in WKT form.  The CRS of the values is WGS 84 with axis order longitude/latitude (CRS84).
     * @param compact The optional compact parameter controls whether the polygon will be filled with zones at the target resolution level only (compact&#x3D;false) or using higher level zones when fully fitting inside the polygon (compact&#x3D;true) 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param properties A comma-separated list of values with names of observable properties that should be returned in the response. The default is to return all observed properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdPolygonGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, bbox?: Array<number>, polygon?: string, compact?: boolean, datetime?: string, properties?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<ZoneCollectionGeoJSON>;
    public collectionsCollectionIdPolygonGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, bbox?: Array<number>, polygon?: string, compact?: boolean, datetime?: string, properties?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdPolygonGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, bbox?: Array<number>, polygon?: string, compact?: boolean, datetime?: string, properties?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdPolygonGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, bbox?: Array<number>, polygon?: string, compact?: boolean, datetime?: string, properties?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdPolygonGet.');
        }
        if (resolution === null || resolution === undefined) {
            throw new Error('Required parameter resolution was null or undefined when calling collectionsCollectionIdPolygonGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (bbox) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                bbox.join(COLLECTION_FORMATS['csv']), 'bbox');
        }
        if (polygon !== undefined && polygon !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>polygon, 'polygon');
        }
        if (compact !== undefined && compact !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>compact, 'compact');
        }
        if (resolution !== undefined && resolution !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>resolution, 'resolution');
        }
        if (datetime !== undefined && datetime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>datetime, 'datetime');
        }
        if (properties) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                properties.join(COLLECTION_FORMATS['csv']), 'properties');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/geo+json',
                'application/dggs+json',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<ZoneCollectionGeoJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/polygon`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Access the definition of a particular zone
     * @param collectionId local identifier of a collection
     * @param zoneId 
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param properties A comma-separated list of values with names of observable properties that should be returned in the response. The default is to return all observed properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdZoneGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, properties?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<ZoneGeoJSON>;
    public collectionsCollectionIdZoneGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, properties?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<ZoneGeoJSON>>;
    public collectionsCollectionIdZoneGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, properties?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<ZoneGeoJSON>>;
    public collectionsCollectionIdZoneGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', zoneId: string, datetime?: string, properties?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdZoneGet.');
        }
        if (zoneId === null || zoneId === undefined) {
            throw new Error('Required parameter zoneId was null or undefined when calling collectionsCollectionIdZoneGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (zoneId !== undefined && zoneId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>zoneId, 'zoneId');
        }
        if (datetime !== undefined && datetime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>datetime, 'datetime');
        }
        if (properties) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                properties.join(COLLECTION_FORMATS['csv']), 'properties');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/geo+json',
                'application/dggs+json',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<ZoneGeoJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/zone`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Access the list of zones in a given DGGS. Can list either all the zones, or a particular subset based on resolution, WGS84 bbox, or list of containing zones (e.g., polygon defined in DGGS terms)
     * @param collectionId local identifier of a collection
     * @param resolution 
     * @param limit The optional limit parameter limits the number of items that are presented in the response document.  Only items on the first level of the collection in the response document are counted.  Minimum &#x3D; 1. Maximum &#x3D; 10000. Default &#x3D; 10.
     * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
     * @param bbox Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the  CRS includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  The CRS of the values is WGS 84 in longitude/latitude order (CRS84) unless a different coordinate reference system is specified in the parameter &#x60;bbox-crs&#x60;.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
     * @param geom A Well Known Text representation of a (MULTI)POLYGON geometry as defined in Simple Feature Access - Part 1: Common Architecture.
     * @param zones Comma separated list of zone identifiers
     * @param properties A comma-separated list of values with names of observable properties that should be returned in the response. The default is to return all observed properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdZonesGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, limit?: number, datetime?: string, bbox?: Array<number>, geom?: string, zones?: Array<string>, properties?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<ZoneCollectionGeoJSON>;
    public collectionsCollectionIdZonesGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, limit?: number, datetime?: string, bbox?: Array<number>, geom?: string, zones?: Array<string>, properties?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdZonesGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, limit?: number, datetime?: string, bbox?: Array<number>, geom?: string, zones?: Array<string>, properties?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<ZoneCollectionGeoJSON>>;
    public collectionsCollectionIdZonesGet(collectionId: 'dggs:H3' | 'dggs:TB16-Pix' | 'dggs:s2-h3' | 'dggs:s2-rpix', resolution: number, limit?: number, datetime?: string, bbox?: Array<number>, geom?: string, zones?: Array<string>, properties?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/geo+json' | 'application/dggs+json' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdZonesGet.');
        }
        if (resolution === null || resolution === undefined) {
            throw new Error('Required parameter resolution was null or undefined when calling collectionsCollectionIdZonesGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (resolution !== undefined && resolution !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>resolution, 'resolution');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (datetime !== undefined && datetime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>datetime, 'datetime');
        }
        if (bbox) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                bbox.join(COLLECTION_FORMATS['csv']), 'bbox');
        }
        if (geom !== undefined && geom !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>geom, 'geom');
        }
        if (zones) {
            zones.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'zones');
            })
        }
        if (properties) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                properties.join(COLLECTION_FORMATS['csv']), 'properties');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/geo+json',
                'application/dggs+json',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<ZoneCollectionGeoJSON>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/zones`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
