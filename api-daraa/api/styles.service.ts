/**
 * Daraa
 * This data store is offered by CubeWerx Inc. as a demonstration of its in-progress OGC API implementation.
 *
 * The version of the OpenAPI document: 9.3.62
 * Contact: mgalluch@cubewerx.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';


import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class StylesService {

    protected basePath = 'https://test.cubewerx.com/cubewerx/cubeserv/demo/ogcapi/Daraa';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * The set of styles available for the specified collection.
     * @param collectionId The identifier of a collection in this data store.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.
     * @param pretty Whether or not the output should be pretty-formatted (with whitespace, etc.).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdStylesGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', f?: 'json' | 'sld11' | 'sld10' | 'html', pretty?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.ogc.sld+xml;version&#x3D;1.1' | 'application/vnd.ogc.sld+xml;version&#x3D;1.0' | 'text/html' | 'application/problem+json' | 'text/xml', context?: HttpContext}): Observable<any>;
    public collectionsCollectionIdStylesGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', f?: 'json' | 'sld11' | 'sld10' | 'html', pretty?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.ogc.sld+xml;version&#x3D;1.1' | 'application/vnd.ogc.sld+xml;version&#x3D;1.0' | 'text/html' | 'application/problem+json' | 'text/xml', context?: HttpContext}): Observable<HttpResponse<any>>;
    public collectionsCollectionIdStylesGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', f?: 'json' | 'sld11' | 'sld10' | 'html', pretty?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.ogc.sld+xml;version&#x3D;1.1' | 'application/vnd.ogc.sld+xml;version&#x3D;1.0' | 'text/html' | 'application/problem+json' | 'text/xml', context?: HttpContext}): Observable<HttpEvent<any>>;
    public collectionsCollectionIdStylesGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', f?: 'json' | 'sld11' | 'sld10' | 'html', pretty?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.ogc.sld+xml;version&#x3D;1.1' | 'application/vnd.ogc.sld+xml;version&#x3D;1.0' | 'text/html' | 'application/problem+json' | 'text/xml', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdStylesGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (f !== undefined && f !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>f, 'f');
        }
        if (pretty !== undefined && pretty !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pretty, 'pretty');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cwApiKeyHeader) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('CubeWerx-API-Key', localVarCredential);
        }

        // authentication (cwApiKeyQuery) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (localVarCredential) {
            localVarQueryParameters = localVarQueryParameters.set('apiKey', localVarCredential);
        }

        // authentication (cwAuth) required
        localVarCredential = this.configuration.lookupCredential('cwAuth');
        if (localVarCredential) {
        }

        // authentication (httpBearer) required
        localVarCredential = this.configuration.lookupCredential('httpBearer');
        if (localVarCredential) {
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json',
                'application/vnd.ogc.sld+xml;version=1.1',
                'application/vnd.ogc.sld+xml;version=1.0',
                'text/html',
                'application/problem+json',
                'text/xml'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/styles`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove a style from the specified collection.
     * @param collectionId The identifier of a collection in this data store.
     * @param styleId The identifier of a style in this data store.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdStylesStyleIdDelete(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any>;
    public collectionsCollectionIdStylesStyleIdDelete(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public collectionsCollectionIdStylesStyleIdDelete(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public collectionsCollectionIdStylesStyleIdDelete(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdStylesStyleIdDelete.');
        }
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling collectionsCollectionIdStylesStyleIdDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cwApiKeyHeader) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('CubeWerx-API-Key', localVarCredential);
        }

        // authentication (cwApiKeyQuery) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (localVarCredential) {
            localVarQueryParameters = localVarQueryParameters.set('apiKey', localVarCredential);
        }

        // authentication (cwAuth) required
        localVarCredential = this.configuration.lookupCredential('cwAuth');
        if (localVarCredential) {
        }

        // authentication (httpBearer) required
        localVarCredential = this.configuration.lookupCredential('httpBearer');
        if (localVarCredential) {
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.delete<any>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/styles/${encodeURIComponent(String(styleId))}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A style as it pertains to the specified collection.
     * @param collectionId The identifier of a collection in this data store.
     * @param styleId The identifier of a style in this data store.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  If \&quot;json\&quot; is specified, a metadata document is returned.  If \&quot;sld11\&quot; or \&quot;sld10\&quot; is specified, the style is returned as a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  If \&quot;sld11style\&quot; or \&quot;sld10style\&quot; is specified, the style is returned as a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.
     * @param pretty Whether or not the output should be pretty-formatted (with whitespace, etc.).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdStylesStyleIdGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', f?: 'json' | 'sld11' | 'sld10' | 'sld11style' | 'sld10style' | 'html', pretty?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/vnd.ogc.sld+xml; version&#x3D;1.1' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0' | 'application/vnd.ogc.sld+xml; version&#x3D;1.1; styleOnly&#x3D;true' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0; styleOnly&#x3D;true' | 'text/html' | 'application/problem+json' | 'text/xml' | 'application/json', context?: HttpContext}): Observable<any>;
    public collectionsCollectionIdStylesStyleIdGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', f?: 'json' | 'sld11' | 'sld10' | 'sld11style' | 'sld10style' | 'html', pretty?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/vnd.ogc.sld+xml; version&#x3D;1.1' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0' | 'application/vnd.ogc.sld+xml; version&#x3D;1.1; styleOnly&#x3D;true' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0; styleOnly&#x3D;true' | 'text/html' | 'application/problem+json' | 'text/xml' | 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public collectionsCollectionIdStylesStyleIdGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', f?: 'json' | 'sld11' | 'sld10' | 'sld11style' | 'sld10style' | 'html', pretty?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/vnd.ogc.sld+xml; version&#x3D;1.1' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0' | 'application/vnd.ogc.sld+xml; version&#x3D;1.1; styleOnly&#x3D;true' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0; styleOnly&#x3D;true' | 'text/html' | 'application/problem+json' | 'text/xml' | 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public collectionsCollectionIdStylesStyleIdGet(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', f?: 'json' | 'sld11' | 'sld10' | 'sld11style' | 'sld10style' | 'html', pretty?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/vnd.ogc.sld+xml; version&#x3D;1.1' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0' | 'application/vnd.ogc.sld+xml; version&#x3D;1.1; styleOnly&#x3D;true' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0; styleOnly&#x3D;true' | 'text/html' | 'application/problem+json' | 'text/xml' | 'application/json', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdStylesStyleIdGet.');
        }
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling collectionsCollectionIdStylesStyleIdGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (f !== undefined && f !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>f, 'f');
        }
        if (pretty !== undefined && pretty !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pretty, 'pretty');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cwApiKeyHeader) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('CubeWerx-API-Key', localVarCredential);
        }

        // authentication (cwApiKeyQuery) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (localVarCredential) {
            localVarQueryParameters = localVarQueryParameters.set('apiKey', localVarCredential);
        }

        // authentication (cwAuth) required
        localVarCredential = this.configuration.lookupCredential('cwAuth');
        if (localVarCredential) {
        }

        // authentication (httpBearer) required
        localVarCredential = this.configuration.lookupCredential('httpBearer');
        if (localVarCredential) {
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/vnd.ogc.sld+xml; version=1.1',
                'application/vnd.ogc.sld+xml; version=1.0',
                'application/vnd.ogc.sld+xml; version=1.1; styleOnly=true',
                'application/vnd.ogc.sld+xml; version=1.0; styleOnly=true',
                'text/html',
                'application/problem+json',
                'text/xml',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/styles/${encodeURIComponent(String(styleId))}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add or update a style for the specified collection, or just validate a style.
     * @param collectionId The identifier of a collection in this data store.
     * @param styleId The identifier of a style in this data store.
     * @param body The definition of a style for this collection.  This can by a full StyledLayerDescriptor (with a single NamedLayer with a single UserStyle) or just a UserStyle.  If the UserStyle name/ID is present, it must match the style ID specified in the URL.
     * @param dryRun If true, the style is validated, but no change is made on the server.  In this situation, the server returns a status code of 204 on successful validation and a status code of 400 if validation fails.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public collectionsCollectionIdStylesStyleIdPut(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', body: string, dryRun?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any>;
    public collectionsCollectionIdStylesStyleIdPut(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', body: string, dryRun?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public collectionsCollectionIdStylesStyleIdPut(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', body: string, dryRun?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public collectionsCollectionIdStylesStyleIdPut(collectionId: 'AgricultureSrf' | 'CulturePnt' | 'CultureSrf' | 'Daraa_DTED' | 'Daraa_mosaic_2019' | 'FacilityPnt' | 'HydrographyCrv' | 'HydrographySrf' | 'MilitarySrf' | 'SettlementSrf' | 'StructurePnt' | 'TransportationGroundCrv' | 'UtilityInfrastructureCrv' | 'UtilityInfrastructurePnt' | 'VegetationSrf', styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', body: string, dryRun?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (collectionId === null || collectionId === undefined) {
            throw new Error('Required parameter collectionId was null or undefined when calling collectionsCollectionIdStylesStyleIdPut.');
        }
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling collectionsCollectionIdStylesStyleIdPut.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling collectionsCollectionIdStylesStyleIdPut.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (dryRun !== undefined && dryRun !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dryRun, 'dry-run');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cwApiKeyHeader) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('CubeWerx-API-Key', localVarCredential);
        }

        // authentication (cwApiKeyQuery) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (localVarCredential) {
            localVarQueryParameters = localVarQueryParameters.set('apiKey', localVarCredential);
        }

        // authentication (cwAuth) required
        localVarCredential = this.configuration.lookupCredential('cwAuth');
        if (localVarCredential) {
        }

        // authentication (httpBearer) required
        localVarCredential = this.configuration.lookupCredential('httpBearer');
        if (localVarCredential) {
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/vnd.ogc.sld+xml; version=1.1',
            'application/vnd.ogc.sld+xml; version=1.0'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.put<any>(`${this.configuration.basePath}/collections/${encodeURIComponent(String(collectionId))}/styles/${encodeURIComponent(String(styleId))}`,
            body,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * The set of styles available in this data store.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.
     * @param pretty Whether or not the output should be pretty-formatted (with whitespace, etc.).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stylesGet(f?: 'json' | 'sld11' | 'sld10' | 'html', pretty?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.ogc.sld+xml;version&#x3D;1.1' | 'application/vnd.ogc.sld+xml;version&#x3D;1.0' | 'text/html' | 'application/problem+json' | 'text/xml', context?: HttpContext}): Observable<any>;
    public stylesGet(f?: 'json' | 'sld11' | 'sld10' | 'html', pretty?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.ogc.sld+xml;version&#x3D;1.1' | 'application/vnd.ogc.sld+xml;version&#x3D;1.0' | 'text/html' | 'application/problem+json' | 'text/xml', context?: HttpContext}): Observable<HttpResponse<any>>;
    public stylesGet(f?: 'json' | 'sld11' | 'sld10' | 'html', pretty?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.ogc.sld+xml;version&#x3D;1.1' | 'application/vnd.ogc.sld+xml;version&#x3D;1.0' | 'text/html' | 'application/problem+json' | 'text/xml', context?: HttpContext}): Observable<HttpEvent<any>>;
    public stylesGet(f?: 'json' | 'sld11' | 'sld10' | 'html', pretty?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.ogc.sld+xml;version&#x3D;1.1' | 'application/vnd.ogc.sld+xml;version&#x3D;1.0' | 'text/html' | 'application/problem+json' | 'text/xml', context?: HttpContext}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (f !== undefined && f !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>f, 'f');
        }
        if (pretty !== undefined && pretty !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pretty, 'pretty');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cwApiKeyHeader) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('CubeWerx-API-Key', localVarCredential);
        }

        // authentication (cwApiKeyQuery) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (localVarCredential) {
            localVarQueryParameters = localVarQueryParameters.set('apiKey', localVarCredential);
        }

        // authentication (cwAuth) required
        localVarCredential = this.configuration.lookupCredential('cwAuth');
        if (localVarCredential) {
        }

        // authentication (httpBearer) required
        localVarCredential = this.configuration.lookupCredential('httpBearer');
        if (localVarCredential) {
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json',
                'application/vnd.ogc.sld+xml;version=1.1',
                'application/vnd.ogc.sld+xml;version=1.0',
                'text/html',
                'application/problem+json',
                'text/xml'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/styles`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a new style to this data store, or just validate a style.
     * @param body The definition of an OGG-API style.  There are two ways of representing such a style in SLD.  The first is by using a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  The second is by using a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.  Either way, the style must not already exist, and all referenced collections must exist and be of a compatible type.
     * @param dryRun If true, the style is validated, but no change is made on the server.  In this situation, the server returns a status code of 204 on successful validation and a status code of 400 if validation fails.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stylesPost(body: string, dryRun?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any>;
    public stylesPost(body: string, dryRun?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public stylesPost(body: string, dryRun?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public stylesPost(body: string, dryRun?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling stylesPost.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (dryRun !== undefined && dryRun !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dryRun, 'dry-run');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cwApiKeyHeader) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('CubeWerx-API-Key', localVarCredential);
        }

        // authentication (cwApiKeyQuery) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (localVarCredential) {
            localVarQueryParameters = localVarQueryParameters.set('apiKey', localVarCredential);
        }

        // authentication (cwAuth) required
        localVarCredential = this.configuration.lookupCredential('cwAuth');
        if (localVarCredential) {
        }

        // authentication (httpBearer) required
        localVarCredential = this.configuration.lookupCredential('httpBearer');
        if (localVarCredential) {
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/vnd.ogc.sld+xml; version=1.1',
            'application/vnd.ogc.sld+xml; version=1.0'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/styles`,
            body,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove a style from this data store.
     * @param styleId The identifier of a style in this data store.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stylesStyleIdDelete(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any>;
    public stylesStyleIdDelete(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public stylesStyleIdDelete(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public stylesStyleIdDelete(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling stylesStyleIdDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cwApiKeyHeader) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('CubeWerx-API-Key', localVarCredential);
        }

        // authentication (cwApiKeyQuery) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (localVarCredential) {
            localVarQueryParameters = localVarQueryParameters.set('apiKey', localVarCredential);
        }

        // authentication (cwAuth) required
        localVarCredential = this.configuration.lookupCredential('cwAuth');
        if (localVarCredential) {
        }

        // authentication (httpBearer) required
        localVarCredential = this.configuration.lookupCredential('httpBearer');
        if (localVarCredential) {
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.delete<any>(`${this.configuration.basePath}/styles/${encodeURIComponent(String(styleId))}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A style in this data store.
     * @param styleId The identifier of a style in this data store.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  If \&quot;json\&quot; is specified, a metadata document is returned.  If \&quot;sld11\&quot; or \&quot;sld10\&quot; is specified, the style is returned as a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  If \&quot;sld11style\&quot; or \&quot;sld10style\&quot; is specified, the style is returned as a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.
     * @param pretty Whether or not the output should be pretty-formatted (with whitespace, etc.).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stylesStyleIdGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', f?: 'json' | 'sld11' | 'sld10' | 'sld11style' | 'sld10style' | 'html', pretty?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/vnd.ogc.sld+xml; version&#x3D;1.1' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0' | 'application/vnd.ogc.sld+xml; version&#x3D;1.1; styleOnly&#x3D;true' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0; styleOnly&#x3D;true' | 'text/html' | 'application/problem+json' | 'text/xml' | 'application/json', context?: HttpContext}): Observable<any>;
    public stylesStyleIdGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', f?: 'json' | 'sld11' | 'sld10' | 'sld11style' | 'sld10style' | 'html', pretty?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/vnd.ogc.sld+xml; version&#x3D;1.1' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0' | 'application/vnd.ogc.sld+xml; version&#x3D;1.1; styleOnly&#x3D;true' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0; styleOnly&#x3D;true' | 'text/html' | 'application/problem+json' | 'text/xml' | 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public stylesStyleIdGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', f?: 'json' | 'sld11' | 'sld10' | 'sld11style' | 'sld10style' | 'html', pretty?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/vnd.ogc.sld+xml; version&#x3D;1.1' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0' | 'application/vnd.ogc.sld+xml; version&#x3D;1.1; styleOnly&#x3D;true' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0; styleOnly&#x3D;true' | 'text/html' | 'application/problem+json' | 'text/xml' | 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public stylesStyleIdGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', f?: 'json' | 'sld11' | 'sld10' | 'sld11style' | 'sld10style' | 'html', pretty?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/vnd.ogc.sld+xml; version&#x3D;1.1' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0' | 'application/vnd.ogc.sld+xml; version&#x3D;1.1; styleOnly&#x3D;true' | 'application/vnd.ogc.sld+xml; version&#x3D;1.0; styleOnly&#x3D;true' | 'text/html' | 'application/problem+json' | 'text/xml' | 'application/json', context?: HttpContext}): Observable<any> {
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling stylesStyleIdGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (f !== undefined && f !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>f, 'f');
        }
        if (pretty !== undefined && pretty !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pretty, 'pretty');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cwApiKeyHeader) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('CubeWerx-API-Key', localVarCredential);
        }

        // authentication (cwApiKeyQuery) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (localVarCredential) {
            localVarQueryParameters = localVarQueryParameters.set('apiKey', localVarCredential);
        }

        // authentication (cwAuth) required
        localVarCredential = this.configuration.lookupCredential('cwAuth');
        if (localVarCredential) {
        }

        // authentication (httpBearer) required
        localVarCredential = this.configuration.lookupCredential('httpBearer');
        if (localVarCredential) {
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/vnd.ogc.sld+xml; version=1.1',
                'application/vnd.ogc.sld+xml; version=1.0',
                'application/vnd.ogc.sld+xml; version=1.1; styleOnly=true',
                'application/vnd.ogc.sld+xml; version=1.0; styleOnly=true',
                'text/html',
                'application/problem+json',
                'text/xml',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/styles/${encodeURIComponent(String(styleId))}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A legend image showing a graphical representation of the specified style, broken down by each of the collections that it\&#39;s capable of rendering.
     * @param styleId The identifier of a style in this data store.
     * @param transparent Whether or not the background of the image should be transparent (when supported by the requested image format).
     * @param bgcolor Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
     * @param textcolor Hexadecimal red-green-blue color value for the text color.  If not specified, a color that contrasts the background color will be used.
     * @param f A token indicating the content type to return.  Overrides the HTTP \&quot;Accept\&quot; header if present.  A value of \&quot;jop\&quot; (content type \&quot;image/x-jpegorpng\&quot;) indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \&quot;wkb\&quot; indicates CubeWerx\&#39;s raster extension to the Well-Known-Binary format.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stylesStyleIdLegendGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any>;
    public stylesStyleIdLegendGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public stylesStyleIdLegendGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public stylesStyleIdLegendGet(styleId: 'Topographic' | 'Overlay' | 'Night' | 'default', transparent?: boolean, bgcolor?: string, textcolor?: string, f?: 'jop' | 'jpeg' | 'png' | 'tiff' | 'gif' | 'wkb', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/x-jpegorpng' | 'image/jpeg' | 'image/png' | 'image/tiff' | 'image/gif' | 'application/x-cubewerx-wkb' | 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling stylesStyleIdLegendGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (transparent !== undefined && transparent !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>transparent, 'transparent');
        }
        if (bgcolor !== undefined && bgcolor !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>bgcolor, 'bgcolor');
        }
        if (textcolor !== undefined && textcolor !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>textcolor, 'textcolor');
        }
        if (f !== undefined && f !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>f, 'f');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cwApiKeyHeader) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('CubeWerx-API-Key', localVarCredential);
        }

        // authentication (cwApiKeyQuery) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (localVarCredential) {
            localVarQueryParameters = localVarQueryParameters.set('apiKey', localVarCredential);
        }

        // authentication (cwAuth) required
        localVarCredential = this.configuration.lookupCredential('cwAuth');
        if (localVarCredential) {
        }

        // authentication (httpBearer) required
        localVarCredential = this.configuration.lookupCredential('httpBearer');
        if (localVarCredential) {
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/x-jpegorpng',
                'image/jpeg',
                'image/png',
                'image/tiff',
                'image/gif',
                'application/x-cubewerx-wkb',
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/styles/${encodeURIComponent(String(styleId))}/legend`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a new style to this data store, redefine an existing style, or just validate a style.
     * @param styleId The identifier of a (new or existing) style in this data store.
     * @param body The definition of an OGG-API style.  There are two ways of representing such a style in SLD.  The first is by using a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  The second is by using a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.  Either way, all referenced collections must exist and be of the compatible type.  If this style already exists, its definition will get updated on the server.  Otherwise it will get created on the server.
     * @param dryRun If true, the style is validated, but no change is made on the server.  In this situation, the server returns a status code of 204 on successful validation and a status code of 400 if validation fails.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stylesStyleIdPut(styleId: string, body: string, dryRun?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any>;
    public stylesStyleIdPut(styleId: string, body: string, dryRun?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public stylesStyleIdPut(styleId: string, body: string, dryRun?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public stylesStyleIdPut(styleId: string, body: string, dryRun?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/problem+json' | 'text/xml' | 'text/html' | 'application/json', context?: HttpContext}): Observable<any> {
        if (styleId === null || styleId === undefined) {
            throw new Error('Required parameter styleId was null or undefined when calling stylesStyleIdPut.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling stylesStyleIdPut.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (dryRun !== undefined && dryRun !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dryRun, 'dry-run');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cwApiKeyHeader) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyHeader');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('CubeWerx-API-Key', localVarCredential);
        }

        // authentication (cwApiKeyQuery) required
        localVarCredential = this.configuration.lookupCredential('cwApiKeyQuery');
        if (localVarCredential) {
            localVarQueryParameters = localVarQueryParameters.set('apiKey', localVarCredential);
        }

        // authentication (cwAuth) required
        localVarCredential = this.configuration.lookupCredential('cwAuth');
        if (localVarCredential) {
        }

        // authentication (httpBearer) required
        localVarCredential = this.configuration.lookupCredential('httpBearer');
        if (localVarCredential) {
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        // authentication (oauth2) required
        localVarCredential = this.configuration.lookupCredential('oauth2');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/problem+json',
                'text/xml',
                'text/html',
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/vnd.ogc.sld+xml; version=1.1',
            'application/vnd.ogc.sld+xml; version=1.0'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.put<any>(`${this.configuration.basePath}/styles/${encodeURIComponent(String(styleId))}`,
            body,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
